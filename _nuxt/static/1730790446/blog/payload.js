__NUXT_JSONP__("/blog", (function(a,b,c,d,e,f,g,h,i,j,k,l,m){return {data:[{posts:[{id:i,uuid:"f9ef9b98-38c9-4301-a701-e89e364b2688",title:"Using axios interceptors in Frontend",slug:"using-axios-interceptors-in-frontend",html:"\u003Cp\u003EAxios is the go-to library for managing HTTP requests in web development. While many developers have started using the native \u003Ccode\u003Efetch\u003C\u002Fcode\u003E API, if your requirements are more complex and you need a reliable solution, Axios remains the top choice. It offers a range of built-in features that are either challenging or not feasible to achieve with \u003Ccode\u003Efetch\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cp\u003EInterceptors are such a feature in Axios that allows us to intercept HTTP requests or responses, making it possible to implement useful patterns that enhance the user experience. They function like middleware, being triggered before Axios resolves the request or response promise with \u003Ccode\u003E.then()\u003C\u002Fcode\u003E or \u003Ccode\u003E.catch()\u003C\u002Fcode\u003E. As you might expect, Axios provides two types of interceptors: one for requests and another for responses. Let's explore both types, using two common patterns in modern web development.\u003C\u002Fp\u003E\u003Cp\u003EBefore that, here is the basic structure of interceptors. Ref - \u003Ca href=\"https:\u002F\u002Faxios-http.com\u002Fdocs\u002Finterceptors?ref=thekhairul.dev\" rel=\"noreferrer\"\u003EAxios documentation\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u002F\u002F request interceptor\naxios.interceptors.request.use(function (config) {\n    \u002F\u002F Do something before request is sent\n    return config;\n  }, function (error) {\n    \u002F\u002F Do something with request error\n    return Promise.reject(error);\n  });\n\n\u002F\u002F response interceptor\naxios.interceptors.response.use(function (response) {\n    \u002F\u002F Any status code that lie within the range of 2xx cause this function to trigger\n    \u002F\u002F Do something with response data\n    return response;\n  }, function (error) {\n    \u002F\u002F Any status codes that falls outside the range of 2xx cause this function to trigger\n    \u002F\u002F Do something with response error\n    return Promise.reject(error);\n  });\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3 id=\"handling-refresh-token-with-request-interceptor\"\u003EHandling refresh token with request interceptor\u003C\u002Fh3\u003E\u003Cp\u003EWhen managing authentication with JWT tokens, it's common practice to use refresh tokens alongside access tokens to prevent users from needing to log in frequently. Since access tokens are short-lived for security reasons, they must be periodically refreshed using the refresh token. The Axios request interceptor is the ideal place to handle this process.\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Eaxios.interceptors.request.use(async function (config) {\n    \u002F\u002F suppose we stored auth tokens in localStorage at the time of login\n    let { accessToken, expiresAt, refreshToken } = JSON.parse(localStorage.getItem(\"auth\"));\n    const hasAccessTokenExpired = new Date().getTime() &gt;= expiresAt;\n    if (hasAccessTokenExpired) {\n        \u002F\u002F refresh the access token\n        try {\n            const response = await axios.post(\"\u002Fapi\u002Fauth\u002Frefresh-token\", {\n                refreshToken,\n            });\n            \u002F\u002F store the new tokens in localStorage\n            localStorage.setItem(\"auth\", JSON.stringify(response.data));\n            accessToken = response.data.accessToken;\n        } catch (err) {\n            throw new Error(\"Invalid refresh token!\");\n        }\n    }\n    config.headers.Authorization = `Bearer ${accessToken}`;\n    return config;\n},\n(error) =&gt; {\n    return Promise.reject(error);\n});\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3 id=\"retry-on-error-with-response-interceptor\"\u003ERetry on error with response interceptor\u003C\u002Fh3\u003E\u003Cp\u003EA request may occasionally fail due to a temporary server issue, and retrying it could resolve the problem. In such cases, an automatic retry mechanism can be useful. However, it's important to ensure that retries are only attempted for errors that are likely to be recoverable, such as 408, 429, 500, 502, 503, and 504. Otherwise, it will be just a waste of resources.\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Eaxios.interceptors.response.use(\n    function (response) {\n        \u002F\u002F if the request succeeded, simply return the response\n        return response;\n    },\n    async function (error) {\n        \u002F\u002F if the request failed, retry once more\n        const { config, response } = error;\n\n        \u002F\u002F Only retry for 429, 500, 502, 503 and 504 status codes\n        if (!response || [429, 500, 502, 503, 504].includes(response.status)) {\n            return Promise.reject(error);\n        }\n\n        \u002F\u002F Avoid infinite retry loops\n        if (config._retry) {\n            return Promise.reject(error);\n        }\n\n        config._retry = true;\n\n        try {\n            \u002F\u002F Retry the original request\n            return await axios(config);\n        } catch (retryError) {\n            return Promise.reject(retryError);\n        }\n    }\n);\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E",comment_id:i,feature_image:"https:\u002F\u002Fimages.unsplash.com\u002Fphoto-1524314010015-136ee8ae1ab3?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3wxMTc3M3wwfDF8c2VhcmNofDN8fGxvb20lMjBzaHV0dGxlJTIwaW50ZXJjZXxlbnwwfHx8fDE3MzA3ODUxNTR8MA&ixlib=rb-4.0.3&q=80&w=2000",featured:b,visibility:g,created_at:"2024-10-28T05:32:27.000+00:00",updated_at:"2024-11-05T05:41:31.000+00:00",published_at:"2024-11-05T05:24:10.000+00:00",custom_excerpt:a,codeinjection_head:a,codeinjection_foot:a,custom_template:a,canonical_url:a,tags:[],authors:[{id:c,name:d,slug:e,profile_image:a,cover_image:a,bio:a,website:a,location:a,facebook:a,twitter:a,meta_title:a,meta_description:a,url:f}],primary_author:{id:c,name:d,slug:e,profile_image:a,cover_image:a,bio:a,website:a,location:a,facebook:a,twitter:a,meta_title:a,meta_description:a,url:f},primary_tag:a,url:"https:\u002F\u002Fthekhairul.dev\u002Fusing-axios-interceptors-in-frontend\u002F",excerpt:"Axios is the go-to library for managing HTTP requests in web development. While many developers have started using the native fetch API, if your requirements are more complex and you need a reliable solution, Axios remains the top choice. It offers a range of built-in features that are either challenging or not feasible to achieve with fetch.\n\nInterceptors are such a feature in Axios that allows us to intercept HTTP requests or responses, making it possible to implement useful patterns that enha",reading_time:j,access:h,comments:b,og_image:a,og_title:a,og_description:a,twitter_image:a,twitter_title:a,twitter_description:a,meta_title:a,meta_description:a,email_subject:a,frontmatter:a,feature_image_alt:a,feature_image_caption:"\u003Cspan style=\"white-space: pre-wrap;\"\u003EPhoto by \u003C\u002Fspan\u003E\u003Ca href=\"https:\u002F\u002Funsplash.com\u002F@anniespratt?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit\"\u003E\u003Cspan style=\"white-space: pre-wrap;\"\u003EAnnie Spratt\u003C\u002Fspan\u003E\u003C\u002Fa\u003E\u003Cspan style=\"white-space: pre-wrap;\"\u003E \u002F \u003C\u002Fspan\u003E\u003Ca href=\"https:\u002F\u002Funsplash.com\u002F?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit\"\u003E\u003Cspan style=\"white-space: pre-wrap;\"\u003EUnsplash\u003C\u002Fspan\u003E\u003C\u002Fa\u003E"},{id:k,uuid:"33164db4-fd7e-42ff-af98-241ca19faf0a",title:"Organizing API calls in frontend - why & how",slug:"organizing-api-calls-in-frontend-why-how",html:"\u003Cp\u003EAPI calls are often a significant part of most web applications, if not the most critical aspect. However, many projects lack proper organization for these calls, leading developers to scatter API calls throughout the codebase.\u003C\u002Fp\u003E\u003Ch3 id=\"why-should-we-care\"\u003EWhy should we care?\u003C\u002Fh3\u003E\u003Cp\u003E\u003Cstrong\u003EMaintainability\u003C\u002Fstrong\u003E: Writing API calls haphazardly can quickly lead to a tangled mess. This approach often results in repeated imports of API libraries across various files, leading to code duplication and increased chances of errors. By centralizing API calls and categorizing them, we can eliminate redundancy and reduce the risk of future bugs, making the codebase clearer and easier to navigate.\u003C\u002Fp\u003E\u003Cp\u003E\u003Cstrong\u003EPerformance Optimization\u003C\u002Fstrong\u003E: Well-organized API calls can enhance performance by minimizing unnecessary requests, implementing caching strategies, and batching requests when suitable. This organization simplifies the use of libraries like React Query, RTK Query, and SWR.\u003C\u002Fp\u003E\u003Cp\u003E\u003Cstrong\u003ETesting\u003C\u002Fstrong\u003E: Having a structured approach to API calls facilitates the writing of unit and integration tests. With a clear organization, itâ€™s easier to mock API responses effectively, ensuring our application functions as intended.\u003C\u002Fp\u003E\u003Ch3 id=\"how-to-organize\"\u003EHow to organize\u003C\u002Fh3\u003E\u003Cp\u003EWe can streamline our API calls by centralizing them through a Data Access Layer (DAL) using the repository pattern. We'll utilize Axios for API requests and JSONPlaceholder as our endpoint source.\u003C\u002Fp\u003E\u003Cp\u003ETo start, we'll create a folder called \u003Ccode\u003Eservices\u003C\u002Fcode\u003E to house all our API-related functionality. Inside this folder, we'll add a file named \u003Ccode\u003EapiClient.js\u003C\u002Fcode\u003E, where we'll import the Axios library and set up a custom Axios client with our shared API configurations.\u003C\u002Fp\u003E\u003Cfigure class=\"kg-card kg-image-card kg-card-hascaption\"\u003E\u003Cimg src=\"https:\u002F\u002Fdigitalpress.fra1.cdn.digitaloceanspaces.com\u002Fh7kyq5r\u002F2024\u002F11\u002Fcode-1.png\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"1316\" height=\"732\"\u003E\u003Cfigcaption\u003E\u003Cspan style=\"white-space: pre-wrap;\"\u003E\u002Fservices\u002FapiClient.js\u003C\u002Fspan\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003ENext, we'll create separate files (repositories) for each set of API resources, as API endpoints are typically organized by resource groups. For our example, JSONPlaceholder has resource groups like \u003Ccode\u003E\u002Fposts\u003C\u002Fcode\u003E, \u003Ccode\u003E\u002Ftodos\u003C\u002Fcode\u003E, and \u003Ccode\u003E\u002Fusers\u003C\u002Fcode\u003E. To keep it simple, we'll focus on just \u003Ccode\u003E\u002Fposts\u003C\u002Fcode\u003E and \u003Ccode\u003E\u002Ftodos\u003C\u002Fcode\u003E. While the repository pattern traditionally uses classes, weâ€™ll simplify things by using plain objects.\u003C\u002Fp\u003E\u003Cfigure class=\"kg-card kg-image-card kg-card-hascaption\"\u003E\u003Cimg src=\"https:\u002F\u002Fdigitalpress.fra1.cdn.digitaloceanspaces.com\u002Fh7kyq5r\u002F2024\u002F11\u002Fcode.png\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"1358\" height=\"1304\"\u003E\u003Cfigcaption\u003E\u003Cspan style=\"white-space: pre-wrap;\"\u003E\u002Fservicecs\u002FpostsRepo.js\u003C\u002Fspan\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003ELet's create another similar repo for \u003Ccode\u003E\u002Ftodos\u003C\u002Fcode\u003E endpoints\u003C\u002Fp\u003E\u003Cfigure class=\"kg-card kg-image-card kg-card-hascaption\"\u003E\u003Cimg src=\"https:\u002F\u002Fdigitalpress.fra1.cdn.digitaloceanspaces.com\u002Fh7kyq5r\u002F2024\u002F11\u002Fcode-2.png\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"1358\" height=\"1304\"\u003E\u003Cfigcaption\u003E\u003Cspan style=\"white-space: pre-wrap;\"\u003E\u002Fservices\u002FtodosRepo.js\u003C\u002Fspan\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003ENow that we are done with creating our repos and client, let's consolidate everything into a single, organized object. Weâ€™ll add an \u003Ccode\u003Eindex.js\u003C\u002Fcode\u003E file in the \u003Ccode\u003E\u002Fservices\u003C\u002Fcode\u003E directory to gather all our repositories while maintaining their resource group organization.\u003C\u002Fp\u003E\u003Cfigure class=\"kg-card kg-image-card kg-card-hascaption\"\u003E\u003Cimg src=\"https:\u002F\u002Fdigitalpress.fra1.cdn.digitaloceanspaces.com\u002Fh7kyq5r\u002F2024\u002F11\u002Fcode-3.png\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"964\" height=\"688\"\u003E\u003Cfigcaption\u003E\u003Cspan style=\"white-space: pre-wrap;\"\u003E\u002Fservices\u002Findex.js\u003C\u002Fspan\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\u003Cp\u003ENow we can use this \u003Ccode\u003E$api\u003C\u002Fcode\u003E object  anywhere we need to call our APIs\u003C\u002Fp\u003E\u003Cfigure class=\"kg-card kg-image-card\"\u003E\u003Cimg src=\"https:\u002F\u002Fdigitalpress.fra1.cdn.digitaloceanspaces.com\u002Fh7kyq5r\u002F2024\u002F11\u002Fcode-4.png\" class=\"kg-image\" alt=\"\" loading=\"lazy\" width=\"1344\" height=\"1216\"\u003E\u003C\u002Ffigure\u003E\u003Cp\u003EAs you can see, this approach is much cleaner than repeating API calls throughout the application. If we need to change a URL or the format of the data, we only have to update the \u003Ccode\u003EapiClient\u003C\u002Fcode\u003E or relevant repositories, making maintenance easier.\u003C\u002Fp\u003E",comment_id:k,feature_image:"https:\u002F\u002Fimages.unsplash.com\u002Fuploads\u002F1413222992504f1b734a6\u002F1928e537?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3wxMTc3M3wwfDF8c2VhcmNofDE0fHxvcmdhbml6ZSUyMGNhbGx8ZW58MHx8fHwxNzMwNDc2MjcyfDA&ixlib=rb-4.0.3&q=80&w=2000",featured:b,visibility:g,created_at:"2024-10-24T04:30:52.000+00:00",updated_at:l,published_at:l,custom_excerpt:a,codeinjection_head:a,codeinjection_foot:a,custom_template:a,canonical_url:a,tags:[],authors:[{id:c,name:d,slug:e,profile_image:a,cover_image:a,bio:a,website:a,location:a,facebook:a,twitter:a,meta_title:a,meta_description:a,url:f}],primary_author:{id:c,name:d,slug:e,profile_image:a,cover_image:a,bio:a,website:a,location:a,facebook:a,twitter:a,meta_title:a,meta_description:a,url:f},primary_tag:a,url:"https:\u002F\u002Fthekhairul.dev\u002Forganizing-api-calls-in-frontend-why-how\u002F",excerpt:"API calls are often a significant part of most web applications, if not the most critical aspect. However, many projects lack proper organization for these calls, leading developers to scatter API calls throughout the codebase.\n\n\nWhy should we care?\n\nMaintainability: Writing API calls haphazardly can quickly lead to a tangled mess. This approach often results in repeated imports of API libraries across various files, leading to code duplication and increased chances of errors. By centralizing AP",reading_time:3,access:h,comments:b,og_image:a,og_title:a,og_description:a,twitter_image:a,twitter_title:a,twitter_description:a,meta_title:a,meta_description:a,email_subject:a,frontmatter:a,feature_image_alt:a,feature_image_caption:"\u003Cspan style=\"white-space: pre-wrap;\"\u003EPhoto by \u003C\u002Fspan\u003E\u003Ca href=\"https:\u002F\u002Funsplash.com\u002F@ptrikutam?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit\"\u003E\u003Cspan style=\"white-space: pre-wrap;\"\u003EPavan Trikutam\u003C\u002Fspan\u003E\u003C\u002Fa\u003E\u003Cspan style=\"white-space: pre-wrap;\"\u003E \u002F \u003C\u002Fspan\u003E\u003Ca href=\"https:\u002F\u002Funsplash.com\u002F?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit\"\u003E\u003Cspan style=\"white-space: pre-wrap;\"\u003EUnsplash\u003C\u002Fspan\u003E\u003C\u002Fa\u003E"},{id:m,uuid:"7c58c8e2-9d11-4222-b9e1-848d7c21c6ea",title:"Sequential promise chain and promise chunking in javascript",slug:"sequential-promise-chain-and-promise-chunking-in-javascript",html:"\u003Cdiv class=\"kg-card kg-callout-card kg-callout-card-blue\"\u003E\u003Cdiv class=\"kg-callout-emoji\"\u003EðŸ’¡\u003C\u002Fdiv\u003E\u003Cdiv class=\"kg-callout-text\"\u003EPrerequisite: Javascript \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FArray\u002Freduce?ref=thekhairul.dev\" rel=\"noreferrer\"\u003EArray.prototype.reduce\u003C\u002Fa\u003E and \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FPromise?ref=thekhairul.dev\" rel=\"noreferrer\"\u003EPromise\u003C\u002Fa\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cp\u003EWhile dealing with a group of promises, we usually want to run them in parallel to improve performance. \u003Ccode\u003EPromise.all\u003C\u002Fcode\u003E is our friend in this case. We group our promises in an array and pass it into \u003Ccode\u003EPromise.all\u003C\u002Fcode\u003E \u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Econst promises = [promise1, promise2, promise3];\nPromise.all(promises).then(data =&gt; {\n  console.log(data); \u002F\u002F [result1, result2, result3]\n})\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EBut sometimes, a situation may arise when we can't run the promises concurrently even if they belong to the same group. For example, if one promise depends on the result of its previous promise, we must do our async operations sequentially one by one.\u003C\u002Fp\u003E\u003Ch2 id=\"sequential-promise-with-for-loop\"\u003Esequential promise with for loop\u003C\u002Fh2\u003E\u003Cp\u003EIf you prefer simplicity or want more control, use a for loop to create the sequence\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Easync function executeSequentially(promises) {\n    const results = [];\n    for (const promise of promises) {\n        const result = await promise(); \u002F\u002F Await each promise\n        results.push(result); \u002F\u002F Collect result when promise resolves\n    }\n    return results;\n}\n\nconst promises = [promise1, promise2, promise3];\nexecuteSequentially(promises).then(results =&gt; {\n  console.log(results); \u002F\u002F [result1, ressult2, result3]\n})\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch2 id=\"sequential-promise-with-arrayprototypereduce\"\u003Esequential promise with Array.prototype.reduce\u003C\u002Fh2\u003E\u003Cp\u003EIf you like the functional approach you can use \u003Ccode\u003Earray.reduce\u003C\u002Fcode\u003E. It is more declarative and has a built-in accumulator that gets passed to each iteration with fresh value from previous callback. So if you are in a situation where one promise depends on the result of previous promise, this pattern \u003Ccode\u003Earray.reduce\u003C\u002Fcode\u003E may feel more intuitive.\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Easync function executeSequentially(promises) {\n  \n  const reducer = async (prevPromise, currPromise) =&gt; {\n    const prevData = await prevPromise;\n    return currPromise.then(result =&gt; prevData.concat(result));\n  }\n  \u002F\u002F we start with a resolved promise returning an accumulator array\n  const results = await promises.reduce(reducer, Promise.resolve([]));\n\n  return results;\n}\n\nconst promises = [promise1, promise2, promise3];\nexecuteSequentially(promises).then(results =&gt; {\n  console.log(results); \u002F\u002F [result1, ressult2, result3]\n})\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch2 id=\"promise-chunking-with-arrayreduce\"\u003EPromise chunking with array.reduce\u003C\u002Fh2\u003E\u003Cp\u003ESo far we've dealt with one single promise at a time. We waited for the previous one to finish before starting next one. Let's try a bit different situation. Suppose we have 10 posts that we want to write into database. That database has a rate limit of 3. We want to use \u003Ccode\u003EPromise.all\u003C\u002Fcode\u003E to initiate all the request at once but that may cause a rate limit error. So we need to build an optimal solution that tackles both issues - use \u003Ccode\u003EPromise.all\u003C\u002Fcode\u003E for performance gain without causing rate limit error.\u003C\u002Fp\u003E\u003Cp\u003ETo achieve this, we will divide our 10 promises into chunks or batches of 3, then run those chunks one by one. We'll use \u003Ccode\u003EPromise.all\u003C\u002Fcode\u003E for each single batch.\u003C\u002Fp\u003E\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Easync function executeSequentially(promiseChunks) {\n  \n  const reducer = async (prevPromiseBatch, currPromiseBatch) =&gt; {\n    const prevDatas = await prevPromiseBatch;\n    return Promise.all(currPromiseBatch)\n      .then(result =&gt; prevDatas.concat(result));\n  }\n  \n  const results = await promiseChunks.reduce(reducer, Promise.resolve([]));\n\n  return results;\n}\n\nconst promiseChunks = [[promise1, promise2, promise3],[promise4, promise5, promise6], [promise7, promise8, promise9], [promise10]];\n\nexecuteSequentially(promiseChunks).then(results =&gt; {\n  console.log(results); \u002F\u002F [result1, ressult2, result3, result4, result5, result6, result7, result8, result9, result10]\n})\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EYou can use \u003Ccode\u003Efor...of\u003C\u002Fcode\u003E loop too but I personally prefer the \u003Ccode\u003Earray.reduce\u003C\u002Fcode\u003E method\u003C\u002Fp\u003E",comment_id:m,feature_image:"https:\u002F\u002Fimages.unsplash.com\u002Fphoto-1656769984643-fdb16bcf4fde?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3wxMTc3M3wwfDF8c2VhcmNofDMxfHxqYXZhc2NyaXB0JTIwcHJvbWlzZSUyMGNoYWlufGVufDB8fHx8MTcyOTgyOTc0M3ww&ixlib=rb-4.0.3&q=80&w=2000",featured:b,visibility:g,created_at:"2024-10-21T16:38:31.000+00:00",updated_at:"2024-11-04T14:35:59.000+00:00",published_at:"2024-10-25T04:20:37.000+00:00",custom_excerpt:a,codeinjection_head:a,codeinjection_foot:a,custom_template:a,canonical_url:a,tags:[],authors:[{id:c,name:d,slug:e,profile_image:a,cover_image:a,bio:a,website:a,location:a,facebook:a,twitter:a,meta_title:a,meta_description:a,url:f}],primary_author:{id:c,name:d,slug:e,profile_image:a,cover_image:a,bio:a,website:a,location:a,facebook:a,twitter:a,meta_title:a,meta_description:a,url:f},primary_tag:a,url:"https:\u002F\u002Fthekhairul.dev\u002Fsequential-promise-chain-and-promise-chunking-in-javascript\u002F",excerpt:"ðŸ’¡Prerequisite: Javascript Array.prototype.reduce and Promise\n\nWhile dealing with a group of promises, we usually want to run them in parallel to improve performance. Promise.all is our friend in this case. We group our promises in an array and pass it into Promise.all\n\nconst promises = [promise1, promise2, promise3];\nPromise.all(promises).then(data =\u003E {\n  console.log(data); \u002F\u002F [result1, result2, result3]\n})\n\nBut sometimes, a situation may arise when we can't run the promises concurrently even i",reading_time:j,access:h,comments:b,og_image:a,og_title:a,og_description:a,twitter_image:a,twitter_title:a,twitter_description:a,meta_title:a,meta_description:a,email_subject:a,frontmatter:a,feature_image_alt:a,feature_image_caption:"\u003Cspan style=\"white-space: pre-wrap;\"\u003EPhoto by \u003C\u002Fspan\u003E\u003Ca href=\"https:\u002F\u002Funsplash.com\u002F@he_junhui?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit\"\u003E\u003Cspan style=\"white-space: pre-wrap;\"\u003EHe Junhui\u003C\u002Fspan\u003E\u003C\u002Fa\u003E\u003Cspan style=\"white-space: pre-wrap;\"\u003E \u002F \u003C\u002Fspan\u003E\u003Ca href=\"https:\u002F\u002Funsplash.com\u002F?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit\"\u003E\u003Cspan style=\"white-space: pre-wrap;\"\u003EUnsplash\u003C\u002Fspan\u003E\u003C\u002Fa\u003E"}]}],fetch:{},mutations:[]}}(null,false,"1","Khairul Anik","khairul","https:\u002F\u002Fthekhairul.dev\u002Fauthor\u002Fkhairul\u002F","public",true,"671f21eb01605f0001195556",2,"6719cd7c01605f0001195516","2024-11-01T15:51:57.000+00:00","6716838701605f0001195419")));